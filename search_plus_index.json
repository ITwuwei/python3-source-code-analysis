{"./":{"url":"./","title":"前言","keywords":"","body":"介绍 本项目致力于对 Python 3.7 的源码分析，深度参考陈儒大大的《Python 源码剖析》，编写 Python 3 的版本。 希望各位 Python 爱好者能参与其中，一起探索 Python 魔法背后的奥秘！ 使用 您可以直接访问 在线版，或者根据以下步骤访问本地版。 前置条件 您的系统上需要安装好 node。 使用 make 命令 若您可使用 make 命令，简单执行如下命令进行初始化： make init 执行如下命令运行服务端： make run 使用 gitbook 命令 若您不能使用 make 命令，或想直接使用 gitbook 命令，执行如下命令进行初始化： npm i -g gitbook-cli #可能需要sudo gitbook install 执行如下命令运行服务端： gitbook serve 访问 直接访问 http://localhost:4000 即可查看本书内容。 Roadmap 大体按照《Python 源码剖析》中的目录结构进行编写。依次介绍 Python 源码基本信息、内建对象和虚拟机。 [x] 章节 [x] 序章 [x] 前言 [x] Python 源代码的组织 [x] Windows 环境下编译 Python [x] UNIX/Linux 环境下编译 Python [x] 修改 Python 源码 [ ] Python 内建对象 [x] Python 对象初探 [ ] Python 整数对象 [ ] Python 字符串 对象 [ ] Python List 对象 [ ] Python Dict 对象 [ ] Python Set 对象 [ ] 实现简版 Python [ ] Python 虚拟机 [ ] Python 编译结果 [ ] Python 虚拟机框架 [ ] 虚拟机一般表达式 [ ] Python 虚拟机控制流 [ ] Python 虚拟机函数机制 [ ] Python 运行环境初始化 [ ] Python 模块加载机制 [ ] Python 多线程机制 [ ] Python 内存管理机制 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"preface/code-organization.html":{"url":"preface/code-organization.html","title":"Python 源代码的组织","keywords":"","body":"Python 源代码的组织 源代码下载 方式 1：GitHub Python 源代码可以在 GitHub 上方便的获取，执行： git clone https://github.com/python/cpython.git git checkout v3.7.0 即可获取 Python 3.7.0 版本的代码。 方式 2：Python 官方网站 访问 https://www.python.org/downloads/release/python-370/ ，下拉至页面最下方，可选择下载 tarball 源码包。 亦可执行： wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 即可获取 Python 3.7.0 版本的代码。 目录结构 进入源码目录，我们可以看到该目录下主要 包含以下文件（夹）： . ├── Doc ├── Grammar ├── Include ├── LICENSE ├── Lib ├── Mac ├── Makefile.pre.in ├── Misc ├── Modules ├── Objects ├── PC ├── PCbuild ├── Parser ├── Programs ├── Python ├── README.rst ├── Tools ├── aclocal.m4 ├── config.guess ├── config.sub ├── configure ├── configure.ac ├── install-sh ├── m4 ├── pyconfig.h.in └── setup.py 其中： Include 目录：包含了 Python 提供的所有头文件，如果用户需要自己用 C 或 C++来编写自定义模块扩展 Python，那么就需要用到这里提供的头文件。 Lib 目录：包含了 Python 自带的所有标准库，且都是用 Python 语言编写的。 Modules 目录：包含了所有用 C 语言编写的模块，比如 math、hashlib 等。它们都是那些对速度要求非常严格的模块。而相比而言，Lib 目录下则是存放一些对速度没有太严格要求的模块，比如 os。 Parser 目录：包含了 Python 解释器中的 Scanner 和 Parser 部分，即对 Python 源代码进行词法分析和语法分析的部分。除此以外，此目录还包含了一些有用的工具，这些工具能够根据 Python 语言的语法自动生成 Python 语言的词法和语法分析器，与 YACC 非常类似。 Objects 目录：包含了所有 Python 的内建对象，包括整数、list、dict 等。同时，该目录还包括了 Python 在运行时需要的所有的内部使用对象的实现。 Python 目录：包含了 Python 解释器中的 Compiler 和执行引擎部分，是 Python 运行的核心所在。 PCbuild 目录：包含了 Visual Studio 2003 的工程文件，研究 Python 源代码就从这里开始（本书将采用 Visual Studio 2017 对 Python 进行编译）。 Programs 目录：包含了 Python 二进制可执行文件的源码。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"preface/windows-build.html":{"url":"preface/windows-build.html","title":"Windows 环境下编译 Python","keywords":"","body":"Windows 环境下编译 Python 在 Windows 环境下编译 Python 可完全通过界面操作，主要分为两个步骤： 环境准备 编译 环境准备 在 Python 3.6 及之后的版本可以使用微软的 Visual Studio 2017 进行编译，选择社区版就足够了。 在下载完成后，需要注意安装环节的选项。由于 Python 3.7 所使用的 Windows SDK 的版本为 10.0.17134.0， 所以需要选择安装该 SDK，如下图所示： 编译 进入 Python 源码根目录，打开 PCbuild\\pcbiuld.sln 解决方案，而后进行一些设置： 在左侧的解决方案目录的顶端，右键选择“属性”，以打开属性界面（如下图所示）。 由于我们只是研究 Python 的核心部分，可以选择不编译标准库和外部依赖，在“配置属性”->“配置”中仅勾选 python 和 pythoncore，然后点击“确定”（如下图所示）。 此外，默认情况下的编译设置是 Debug、32 位，您也可以根据自己的需求调整成 Release 或 64 位。 在左侧的解决方案目录中选择 python，右键选择“生成”，以进行编译： 编译结束后，生成的文件存放在PCbuild\\win32目录下（如下图所示），打开python_d即可打开新生成的 Python 3.7 解释器。 更多内容 更多关于在 Windows 上进行编译和开发 Python 的内容见官方指南 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"preface/unix-linux-build.html":{"url":"preface/unix-linux-build.html","title":"UNIX/Linux 环境下编译 Python","keywords":"","body":"UNIX/Linux 环境下编译 Python 在 UNIX/Linux 环境下编译 Python 较为简单，主要分为两个步骤： 环境准备（准备 Python 所依赖的必要环境） 编译、安装 环境准备 常规操作系统中 编译 Python 前通常需要在系统上安装以下库： gcc // 编译工具 zlib // 压缩、解压相关库 libffi // Python 所以来的用于支持 C 扩展的库 openssl // 安全套接字层密码库，Linux 中通常已具备 不同的发行版，安装方式和包名称也不尽相同。 对于 Debian/Ubuntu，执行： sudo apt install -y zlib1g zlib1g-dev libffi-dev openssl libssl-dev 对于 RedHat/CentOS/Fedora，执行： yum install -y zlib zlib-devel libffi-devel openssl openssl-devel 对于 macOS，执行： xcode-select --install 运行于 Docker 的操作系统中 Docker 版的 Linux 发行版可能会有较多的库未安装，除了安装上一小节提及的库外，其他缺失库可根据情况自行安装： bzip2 // 压缩库 readline // GNU Readline 是一个软件库，它为使用命令行界面（如 Bash）的交互式程序提供了行编辑和历史功能 sqlite // 由 C 编写的小型数据库 libuuid // 跨平台的开源的 uuid 操作库 gdbm // 小型的数据库系统 xz // 压缩解压工具 tk-devel // 图形用户界面开发工具 对于 Debian/Ubuntu，执行： sudo apt-get install bzip2 libbz2-dev sqlite3 libsqlite3-dev libreadline6 libreadline6-dev libgdbm-dev uuid-dev tk-dev 对于 RedHat/CentOS/Fedora，执行： yum install bzip2 bzip2-devel readline-devel sqlite-devel libuuid-devel gdbm-devel xz-devel tk-devel 编译、安装 进入 Python 源码根目录，执行以下命令： ./configure make make install Python 将会被编译，并安装在默认目录中。若您希望将 Python 安装在特定目录，则需要在一开始修改 configure 命令为： ./configure --prefix= 在指定目录中: bin 目录 存放的是可执行文件 include 目录 存放的是 Python 源码的头文件 lib 目录 存放的是 Python 标准库 lib/python3.7/config-3.7m-{platform} 目录 存放的是 libpython3.7m.a，该静态库用于使用 C 语言进行扩展。{platform} 代表平台，比如在 Mac OS 上为 “darwin”，在 Linux 上为 “x86_64-linux-gnu” share 目录 存放的是帮助等文件 默认情况下，编译的 Python 是静态链接（libpython3.7m.a）。如果希望编译的 Python 是动态链接（libpython3.7m.so），则需要在一开始修改configure 命令为： ./configure --enable-shared 如需重新编译，请首先执行： make clean 再执行本节开头处的命令即可。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"preface/modify-code.html":{"url":"preface/modify-code.html","title":"修改 Python 源码","keywords":"","body":"修改 Python 源码 在源代码中 Print 在接下来研究源码的过程中，我们可能会对某些语句的逻辑感到好奇，需要输出中间结果。 这就需要借助 Python C API 中打印对象的接口： 源文件：Objects/object.c int PyObject_Print(PyObject *op, FILE *fp, int flags) 比如，我们希望在解释器交互界面中打印整数值的时候输出一段字符串，则我们可以修改如下函数： 源文件：Objects/longobject.c static PyObject * long_to_decimal_string(PyObject *aa) { PyObject *str = PyUnicode_FromString(\"I am always before int\"); PyObject_Print(str, stdout, 0); printf(\"\\n\"); PyObject *v; if (long_to_decimal_string_internal(aa, &v, NULL, NULL, NULL) == -1) return NULL; return v; } 函数实现中的前 3 行为我们加入的代码，其中： PyUnicode_FromString 用于把 C 中的原生字符数组转换为出 Python 中的字符串（Unicode）对象 PyObject_Print 则将转换好的字符串对象打印至我们指定的标准输出（stdout） 对 Python 重新进行编译，在 Unix 上可执行： make && make bininstall 运行编译后的 Python，输入 print 语句即可看到我们希望的结果： >>> print(1) 'I am always before int' 1 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/object.html":{"url":"objects/object.html","title":"Python 对象初探","keywords":"","body":"Python 对象初探 在Python的世界一切皆对象，不论是整数，还是字符串，甚至连类型、函数等都是一种对象。 对象的分类 以下是Python对象的大致的一个分类 Fundamental 对象: 类型对象 Numeric 对象: 数值对象 Sequence 对象: 容纳其他对象的序列集合对象 Mapping 对象: 类似 C++中的 map 的关联对象 Internal 对象: Python 虚拟机在运行时内部使用的对象 对象机制的基石 PyObject 对于初学者来说这么多类型的对象怎么学？别着急，我们后续章节会解答。 在开始我们的学习之旅之前，我们要先认识一个结构体PyObject，可以说Python的对象机制就是基于PyObject拓展开来的，所以我们先看看PyObject 到底长什么样。 源文件：Include/object.h // Include/object.h #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev; typedef struct _object { _PyObject_HEAD_EXTRA // 双向链表 垃圾回收 需要用到 Py_ssize_t ob_refcnt; // 引用计数 struct _typeobject *ob_type; // 指向类型对象的指针，决定了对象的类型 } PyObject; Python中的所有对象都拥有一些相同的内容，而这些内容就定义在PyObject中， PyObject 包含 一个用于垃圾回收的双向链表，一个引用计数变量 ob_refcnt 和 一个类型对象指针ob_type 定长对象与变长对象 Python对象除了前面提到的那种分类方法外，还可以分为定长对象和变长对象这两种形式。 变长对象都拥有一个相同的内容 PyVarObject，而 PyVarObject也是基于PyObject扩展的。 从代码中可以看出PyVarObject比PyObject多出了一个用于存储元素个数的变量ob_size。 源文件：Include/object.h // Include/object.h typedef struct _object { _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type; } PyObject; typedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; 类型对象 前面我们提到了PyObject 的 对象类型指针struct _typeobject *ob_type，它指向的类型对象就决定了一个对象是什么类型的。 这是一个非常重要的结构体，它不仅仅决定了一个对象的类型，还包含大量的元信息， 包括创建对象需要分配多少内存，对象都支持哪些操作等等。 接下来我们看一下struct _typeobject代码 在 PyTypeObject 的定义中包含许多信息，主要分类以下几类: 类型名, tp_name, 主要用于 Python 内部调试用 创建该类型对象时分配的空间大小信息，即 tp_basicsize 和 tp_itemsize 与该类型对象相关的操作信息(如 tp_print 这样的函数指针) 一些对象属性 源文件：Include/object.h // Include/object.h typedef struct _typeobject { PyObject_VAR_HEAD const char *tp_name; /* For printing, in format \".\" */ // 类型名 Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ // 创建该类型对象分配的内存空间大小 // 一堆方法定义，函数和指针 /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ reprfunc tp_repr; /* Method suites for standard classes */ // 标准类方法集 PyNumberMethods *tp_as_number; // 数值对象操作 PySequenceMethods *tp_as_sequence; // 序列对象操作 PyMappingMethods *tp_as_mapping; // 字典对象操作 // 更多标准操作 /* More standard operations (here for binary compatibility) */ hashfunc tp_hash; ternaryfunc tp_call; reprfunc tp_str; getattrofunc tp_getattro; setattrofunc tp_setattro; ...... } PyTypeObject; 类型的类型 在 PyTypeObjet 定义开始有一个宏PyOject_VAR_HEAD，查看源码可知 PyTypeObjet 是一个变长对象 源文件：Include/object.h // Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; 对象的类型是由该对象指向的 类型对象 决定的，那么类型对象的类型是由谁决定的呢？ 对于其他对象，可以通过与其关联的类型对象确定其类型，那么通过什么来确定一个对象是类型对象呢？ 答案就是 PyType_Type 源文件：Objects/typeobject.c // Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"type\", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ...... }; PyType_Type 在类型机制中至关重要，所有用户自定义 class 所 对应的 PyTypeObject 对象都是通过 PyType_Type创建的 接下来我们看 PyLong_Type 是怎么与 PyType_Type 建立联系的。 前面提到，在Python中，每一个对象都将自己的引用计数、类型信息保存在开始的部分中。 为了方便对这部分内存初始化，Python中提供了几个有用的宏: 源文件：Include/object.h // Include/object.h #ifdef Py_TRACE_REFS #define _PyObject_EXTRA_INIT 0, 0, #else #define _PyObject_EXTRA_INIT #endif #define PyObject_HEAD_INIT(type) \\ { _PyObject_EXTRA_INIT \\ 1, type }, 这些宏在各种内建类型对象的初始化中被大量使用。 以PyLong_Type为例，可以清晰的看到一般的类型对象和PyType_Type之间的关系 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ...... }; 下图是对象运行时的图像表现 对象的创建 Python创建对象有两种方式 范型API 或称为 AOL (Abstract Object Layer) 这类API通常形如PyObject_XXX这样的形式。可以应用在任何Python对象上， 如PyObject_New。创建一个整数对象的方式 PyObject* longobj = PyObject_New(Pyobject, &PyLong_Type); 与类型相关的API 或称为 COL (Concrete Object Layer) 这类API 通常只能作用于某一种类型的对象上，对于每一种内建对象 Python都提供了这样一组API。例如整数对象，我们可以利用如下的API创建 PyObject *longObj = PyLong_FromLong(10); 对象的行为 在 PyTypeObject 中定义了大量的函数指针。这些函数指针可以视为类型对象中 所定义的操作，这些操作直接决定着一个对象在运行时所表现出的行为，比如 PyTypeObject 中的 tp_hash 指明了该类型对象如何生成其hash值。 在PyTypeObject的代码中，我们还可以看到非常重要的三组操作族 PyNumberMethods *tp_as_number PySequenceMethods *tp_as_sequence PyMappingMethods *tp_as_mapping PyNumberMethods 的代码如下 源文件：Include/object.h // Include/object.h typedef PyObject * (*binaryfunc)(PyObject *, PyObject *); typedef struct { binaryfunc nb_matrix_multiply; binaryfunc nb_inplace_matrix_multiply; ...... } PyNumberMethods; PyNumberMethods 定义了一个数值对象该支持的操作。一个数值对象如 整数对象，那么它的类型对象 PyLong_Type中tp_as_number.nb_add 就指定了它进行加法操作时的具体行为。 在以下代码中可以看出PyLong_Type中的tp_as_number项指向的是long_as_number 源文件：Objects/longobject.h // Objects/longobject.c static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ...... }; PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ ...... }; PySequenceMethods *tp_as_sequence 和 PyMappingMethods *tp_as_mapping的分析与PyNumberMethods *tp_as_number 相同，大家可以自行查阅源码 对象的多态性 Python创建一个对象比如 PyLongObject 时，会分配内存进行初始化，然后 Python内部会用 PyObject* 变量来维护这个对象，其他对象也与此类似 所以在 Python 内部各个函数之间传递的都是一种范型指针 PyObject* 我们不知道这个指针所指的对象是什么类型，只能通过所指对象的 ob_type 域 动态进行判断，而Python正是通过 ob_type 实现了多态机制 考虑以下的 calc_hash 函数 Py_hash_t calc_hash(PyObject* object) { Py_hash_t hash = object->ob_type->tp_hash(object); return hash; } 如果传递给 calc_hash 函数的指针是一个 PyLongObject*，那么它会调用 PyLongObject 对象对应的类型对象中定义的 hash操作tp_hash，tp_hash可以在PyTypeObject中找到， 而具体赋值绑定我们可以在 PyLong_Type 初始化代码中看到绑定的是long_hash函数 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ ... (hashfunc)long_hash, /* tp_hash */ ... }; 如果指针是一个 PyUnicodeObject*，那么就会调用 PyUnicodeObject 对象对应的类型对象中定义的hash操作，查看源码可以看到 实际绑定的是 unicode_hash函数 源文件：Objects/unicodeobject.c // Objects/unicodeobject.c PyTypeObject PyUnicode_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"str\", /* tp_name */ ... (hashfunc) unicode_hash, /* tp_hash*/ ... }; 引用计数 Python 通过引用计数来管理维护对象在内存中的存在与否 Python 中的每个东西都是一个对象， 都有ob_refcnt 变量，这个变量维护对象的引用计数，从而最终决定该对象的创建与销毁 在Python中，主要通过 Py_INCREF(op)与Py_DECREF(op) 这两个宏 来增加和减少对一个对象的引用计数。当一个对象的引用计数减少到0之后， Py_DECREF将调用该对象的tp_dealloc来释放对象所占用的内存和系统资源； 但这并不意味着最终一定会调用 free 释放内存空间。因为频繁的申请、释放内存会大大降低Python的执行效率。因此Python中大量采用了内存对象池的技术，使得对象释放的空间归还给内存池而不是直接free，后续使用可先从对象池中获取 源文件：Include/object.h // Include/object.h #define _Py_NewReference(op) ( \\ _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ Py_REFCNT(op) = 1) #define Py_INCREF(op) ( \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ ((PyObject *)(op))->ob_refcnt++) #define Py_DECREF(op) \\ do { \\ PyObject *_py_decref_tmp = (PyObject *)(op); \\ if (_Py_DEC_REFTOTAL _Py_REF_DEBUG_COMMA \\ --(_py_decref_tmp)->ob_refcnt != 0) \\ _Py_CHECK_REFCNT(_py_decref_tmp) \\ else \\ _Py_Dealloc(_py_decref_tmp); \\ } while (0) Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/long-object.html":{"url":"objects/long-object.html","title":"Python 整数对象","keywords":"","body":"Python 整数对象 CPython2 的整数对象 有 PyIntObject 和 PyLongObject 这两种类型， CPython3 只保留了 PyLongObject 在 源文件：Objects/longobject.c 的第三行有这么一句话 XXX The functional organization of this file is terrible 可见这个变化不是一蹴而就的，有比较艰辛的过程，大家有兴趣可以去挖掘一下 PyLongObject 源文件：Include/longobject.h // longobject.h typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ 源文件：Include/longintrepr.h // longintrepr.h /* Long integer representation. The absolute value of a number is equal to 一个数的绝对值等价于下面的表达式 SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i) Negative numbers are represented with ob_size 从源码可以看出 PyLongObject 是变长对象 类型对象 PyLong_Type 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ (hashfunc)long_hash, /* tp_hash */ 0, /* tp_call */ long_to_decimal_string, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LONG_SUBCLASS, /* tp_flags */ long_doc, /* tp_doc */ 0, /* tp_traverse */ 0, /* tp_clear */ long_richcompare, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ long_methods, /* tp_methods */ 0, /* tp_members */ long_getset, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ 0, /* tp_init */ 0, /* tp_alloc */ long_new, /* tp_new */ PyObject_Del, /* tp_free */ }; 小整数对象 一些整数在一开始就会被初始化一直留存，当再次使用直接从小整数对象池中获取，不用频繁的申请内存。 默认的小整数范围是 [-5, 257) 源文件：Objects/longobject.c // Objects/longobject.c #ifndef NSMALLPOSINTS #define NSMALLPOSINTS 257 #endif #ifndef NSMALLNEGINTS #define NSMALLNEGINTS 5 #endif #if NSMALLNEGINTS + NSMALLPOSINTS > 0 /* Small integers are preallocated in this array so that they can be shared. The integers that are preallocated are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive). */ static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS]; #ifdef COUNT_ALLOCS Py_ssize_t quick_int_allocs, quick_neg_int_allocs; #endif static PyObject * get_small_int(sdigit ival) { PyObject *v; assert(-NSMALLNEGINTS = 0) quick_int_allocs++; else quick_neg_int_allocs++; #endif return v; } #define CHECK_SMALL_INT(ival) \\ do if (-NSMALLNEGINTS 宏 CHECK_SMALL_INT 会检查传入的数是否在小整数范围内，如果是直接返回。 可以在创建或复制整数对象等函数中找到 CHECK_SMALL_INT 的身影，以下只列出了 PyLong_FromLong，就不一一列举了 源文件：Objects/longobject.c // Object/longobject.c PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so >> doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); ... } 小整数初始化 源文件：Objects/longobject.c // Objects/longobject.c int _PyLong_Init(void) { #if NSMALLNEGINTS + NSMALLPOSINTS > 0 int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival ob_digit[0] == (digit)abs(ival)); } else { (void)PyObject_INIT(v, &PyLong_Type); } Py_SIZE(v) = size; v->ob_digit[0] = (digit)abs(ival); } #endif _PyLong_Zero = PyLong_FromLong(0); if (_PyLong_Zero == NULL) return 0; _PyLong_One = PyLong_FromLong(1); if (_PyLong_One == NULL) return 0; /* initialize int_info */ if (Int_InfoType.tp_name == NULL) { if (PyStructSequence_InitType2(&Int_InfoType, &int_info_desc) 整数的存储结构 源文件：Objects/longobject.c 在 long_to_decimal_string_internal中添加如下代码并重新编译安装 // Objects/longobject.c static int long_to_decimal_string_internal(PyObject *aa, PyObject **p_output, _PyUnicodeWriter *writer, _PyBytesWriter *bytes_writer, char **bytes_str) { PyLongObject *scratch, *a; PyObject *str = NULL; Py_ssize_t size, strlen, size_a, i, j; digit *pout, *pin, rem, tenpow; int negative; int d; enum PyUnicode_Kind kind; a = (PyLongObject *)aa; // 添加打印代码 printf(\"ob_size = %d\\n\", Py_SIZE(a)); for (int index = 0; index ob_digit[index]); } ... } 编译安装后进入python解释器输入如下代码 num = 9223372043297226753 print(num) # output >>> ob_size = 3 >>> ob_digit[0] = 1 >>> ob_digit[1] = 6 >>> ob_digit[2] = 8 >>> 9223372043297226753 如下图所示 注：这里的 30 是由 PyLong_SHIFT 决定的，64位系统中，PyLong_SHIFT 为30，否则 PyLong_SHIFT 为15 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/string-object.html":{"url":"objects/string-object.html","title":"Python 字符串 对象","keywords":"","body":"Python 字符串 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/list-object.html":{"url":"objects/list-object.html","title":"Python List 对象","keywords":"","body":"Python List 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/dict-object.html":{"url":"objects/dict-object.html","title":"Python Dict 对象","keywords":"","body":"Python Dict 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/set-object.html":{"url":"objects/set-object.html","title":"Python Set 对象","keywords":"","body":"Python Set 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "},"objects/simple-implementation.html":{"url":"objects/simple-implementation.html","title":"实现简版 Python","keywords":"","body":"实现简版 Python Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-03-30 21:58:37 "}}